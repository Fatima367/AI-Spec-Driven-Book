---
title: "ماڈیول 2: ڈیجیٹل ٹوئن اور تقلید"
sidebar_position: 1
---

import { PersonalizeButton, UrduTranslationButton } from '@site/src/components/PersonalizationButtons';
import Mermaid from '@theme/Mermaid';

<PersonalizeButton />
<UrduTranslationButton />

# ماڈیول 2: ڈیجیٹل ٹوئن اور تقلید

## سیکھنے کے اہداف
- ڈیجیٹل ٹوئنز کے تصور اور روبوٹکس کی ترقی میں ان کے اہم کردار کو سمجھنا
- روبوٹکس سسٹمز کے لیے گزیبو اور یونٹی سمیت تقلیدی ماحول کے استعمال میں مہارت حاصل کرنا
- گریویٹی، تصادم، اور سینسر ماڈلنگ کے لیے حقیقی پیرامیٹرز کے ساتھ فزکس تقلید نافذ کرنا
- تقلید کے لیے URDF (یونیفائیڈ روبوٹ ڈسکرپشن فارمیٹ) کا استعمال کرتے ہوئے روبوٹ ماڈلز تخلیق اور کنفیگر کرنا
- ہیومنائیڈ روبوٹس کے لیے سیم ٹو ریئل کے فرق کو بطور مؤثر طریقے سے پُر کرنے والے تقلیدی منظرنامے تیار کرنا
- روبوٹکس کی ترقی اور جانچ کے لیے تقلید کے فوائد اور حدود کا جائزہ لینا

## روبوٹکس میں ڈیجیٹل ٹوئنز کا تعارف

روبوٹکس میں ایک ڈیجیٹل ٹوئن ایک جسمانی روبوٹ یا روبوٹکس سسٹم کا ایک ورچوئل نمونہ ہے جو اس کے حقیقی دنیا کے ہم منازل کو حقیقی وقت میں آئینہ بنا دیتا ہے۔ یہ ورچوئل ماڈل نہ صرف جسمانی جیومیٹری اور کائینیمیٹکس کو احاطہ کرتا ہے بلکہ متحرک سلوک، سینسر کی خصوصیات، اور ماحولیاتی تعاملات کو بھی شامل کرتا ہے۔ ڈیجیٹل ٹوئنز روبوٹکس کو الگورتھم کی جانچ، ڈیزائن کی توثیق، اور AI ماڈلز کی تربیت کو ایک محفوظ، کنٹرول شدہ، اور قیمت کے لحاظ سے مؤثر ورچوئل ماحول میں انجام دینے کی اجازت دیتا ہے جس سے جسمانی ہارڈ ویئر پر منتقل ہونے سے پہلے۔

یہ تصور خاص طور پر ہیومنائیڈ روبوٹکس میں قیمتی ہے، جہاں جسمانی روبوٹس مہنگے ہوتے ہیں، جانچ کے دوران ممکنہ طور پر خطرناک ہوتے ہیں، اور ناکامیوں کے بعد دوبارہ ترتیب دینے میں وقت طلب ہوتے ہیں۔ ڈیجیٹل ٹوئنز کے ذریعے، جسمانی روبوٹ پر منتقل ہونے سے پہلے تقلید میں پیچیدہ ہیومنائیڈ رویے کو تیار، بہتر بنایا، اور توثیق کیا جاسکتا ہے- اس عمل کو سیم ٹو ریئل ٹرانسفر کے نام سے جانا جاتا ہے۔

## تقلیدی ماحول: گزیبو بمقابلہ یونٹی

### گزیبو
گزیبو ایک فزکس پر مبنی تقلیدی ماحول ہے جو حقیقی رینڈرنگ، ہائی فائیڈیلٹی فزکس تقلید، اور سینسر تقلید کی صلاحیات فراہم کرتا ہے۔ یہ گزیبو ROS پیکیجز کے ذریعے ROS/ROS 2 کے ساتھ م无缝 طور پر انضمام فراہم کرتا ہے، جو روبوٹکس کی ترقی کے ورک فلو کے لیے ایک قدرتی انتخاب ہے۔

گزیبو کی خصوصیات:
- ODE، بُلیٹ، یا DART فزکس انجن کا استعمال کرتے ہوئے حقیقی فزکس تقلید
- سینسر تقلید (کیمرے، لائیڈار، IMUs، GPS، وغیرہ)
- متحرک اشیاء کے ساتھ پیچیدہ ماحول
- ایک ہی تقلید میں متعدد روبوٹس کی حمایت
- ROS/ROS 2 کے ساتھ انضمام برائے م无缝 ترقی

### یونٹی
یونٹی ایک طاقتور گیم انجن پر مبنی تقلیدی ماحول فراہم کرتا ہے جو فوٹو ریئلسٹک رینڈرنگ اور پیچیدہ منظر تخلیق میں مہارت رکھتا ہے۔ یونٹی روبوٹکس تقلید کمپیوٹر وژن الگورتھم کی تربیت اور ادراک سسٹم کی جانچ کے لیے بالکل قیمتی ہے۔

یونٹی کی خصوصیات:
- فوٹو ریئلسٹک رینڈرنگ کی صلاحیات
- ایجادی منظر تخلیق
- اعلی درجے کی لائٹنگ اور میٹریل تقلید
- کراس پلیٹ فارم ڈیپلومنٹ
- از پیش تیار ماحول اور ماڈلز کے ساتھ اثاثہ اسٹور

<Mermaid chart={`graph LR;
    A[Physical Robot] -->|State Data| B(Digital Twin);
    B -->|Commands| A;
    B -->|Validation| C[Test Scenarios);
    B -->|Training| D[AI Models);
    E[Simulation Environment] -.-> B;
    E -.-> F[Gazebo];
    E -.-> G[Unity];
`} />

## فزکس تقلید کے بنیادیات

### گریویٹی اور متحرکات
تقلیدی ماحول گریویٹی کے زور، رگڑ، اور تصادم متحرکات کی اچھی طرح نقل کرتے ہیں۔ ہیومنائیڈ روبوٹس کے لیے، اس میں متعدد لنکس اور جوڑوں کے درمیان پیچیدہ تعاملات کی نقل شامل ہے، جو حقیقی حرکت اور توازن کے رویوں کو یقینی بناتا ہے۔

### تصادم کا پتہ لگانا اور جواب
ہیومنائیڈ روبوٹس کے لیے انسانی ماحول میں کام کرنے کے لیے حقیقی تصادم کا پتہ لگانا انتہائی اہم ہے۔ تقلیدی ماحول رابطے کے زور، رگڑ کے ضرائب، اور میٹریل کی خصوصیات کی نقل کرتے ہیں تاکہ اشیاء اور سطحوں کے ساتھ درست تعامل یقینی بنایا جاسکے۔

### سینسر تقلید
تقلیدی ماحول مختلف سینسرز کے حقیقی ماڈل فراہم کرتے ہیں:
- **کیمرے**: عدسہ کی بے نقابی، ریزولوشن، اور فریم کی شرح کی نقل
- **لائیڈار**: لیزر بیم کی خصوصیات، شور، اور رینج کی حدود کی نقل
- **IMUs**: ڈرائیفٹ، شور، اور متحرک جواب کی نقل
- **فورس/ٹارک سینسرز**: پیمائش کے شور اور بینڈ وڈتھ کی حدود کی نقل

## گزیبو کوڈ کی مثالیں

### حسب ضرورت دنیا کے ساتھ تقلید کا آغاز
```xml
<!-- example_world.launch.py -->
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import PathJoinSubstitution
from launch_ros.substitutions import FindPackageShare

def generate_launch_description():
    world_path = PathJoinSubstitution([
        FindPackageShare("my_robot_simulation"),
        "worlds",
        "my_world.sdf"
    ])

    gzserver_launch = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            FindPackageShare("gazebo_ros"),
            "/launch/gzserver.launch.py"
        ]),
        launch_arguments={
            "world": world_path,
            "verbose": "true"
        }.items()
    )

    return LaunchDescription([
        gzserver_launch
    ])
```

### گزیبو میں روبوٹ کو کنٹرول کرنا
```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from sensor_msgs.msg import LaserScan
import math

class GazeboController(Node):
    def __init__(self):
        super().__init__('gazebo_controller')

        # روبوٹ کی رفتار کے حکم کے لیے پبلشر
        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)

        # لیزر اسکین ڈیٹا کے لیے سبسکرائبر
        self.scan_sub = self.create_subscription(
            LaserScan, '/scan', self.scan_callback, 10)

        # کنٹرول لوپ کے لیے ٹائمر
        self.timer = self.create_timer(0.1, self.control_loop)

        self.laser_data = None
        self.obstacle_detected = False

    def scan_callback(self, msg):
        # رکاوٹوں کا پتہ لگانے کے لیے لیزر اسکین کو پروسیس کریں
        min_distance = min(msg.ranges)
        self.obstacle_detected = min_distance < 1.0  # 1 میٹر کی حد
        self.laser_data = msg

    def control_loop(self):
        cmd_vel = Twist()

        if self.obstacle_detected:
            # روکیں اور صاف راستہ تلاش کرنے کے لیے گھومیں
            cmd_vel.linear.x = 0.0
            cmd_vel.angular.z = 0.5  # جگہ پر گھومیں
        else:
            # محفوظ طریقے سے آگے بڑھیں
            cmd_vel.linear.x = 0.5
            cmd_vel.angular.z = 0.0

        self.cmd_vel_pub.publish(cmd_vel)

def main(args=None):
    rclpy.init(args=args)
    controller = GazeboController()
    rclpy.spin(controller)
    controller.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### URDF روبوٹ ماڈل کی مثال
```xml
<?xml version="1.0"?>
<robot name="simple_humanoid">
  <!-- بیس لنک -->
  <link name="base_link">
    <visual>
      <geometry>
        <box size="0.5 0.3 0.2"/>
      </geometry>
      <material name="blue">
        <color rgba="0 0 1 0.8"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <box size="0.5 0.3 0.2"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="5.0"/>
      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1"/>
    </inertial>
  </link>

  <!-- سر -->
  <joint name="head_joint" type="fixed">
    <parent link="base_link"/>
    <child link="head"/>
    <origin xyz="0 0 0.25" rpy="0 0 0"/>
  </joint>

  <link name="head">
    <visual>
      <geometry>
        <sphere radius="0.1"/>
      </geometry>
      <material name="white">
        <color rgba="1 1 1 0.8"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <sphere radius="0.1"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="1.0"/>
      <inertia ixx="0.004" ixy="0.0" ixz="0.0" iyy="0.004" iyz="0.0" izz="0.004"/>
    </inertial>
  </link>

  <!-- بائیں بازو -->
  <joint name="left_shoulder_joint" type="revolute">
    <parent link="base_link"/>
    <child link="left_upper_arm"/>
    <origin xyz="0.3 0.15 0" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>
    <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>
  </joint>

  <link name="left_upper_arm">
    <visual>
      <geometry>
        <cylinder length="0.3" radius="0.05"/>
      </geometry>
      <material name="red">
        <color rgba="1 0 0 0.8"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <cylinder length="0.3" radius="0.05"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="0.5"/>
      <inertia ixx="0.005" ixy="0.0" ixz="0.0" iyy="0.005" iyz="0.0" izz="0.0005"/>
    </inertial>
  </link>
</robot>
```

## یونٹی تقلید کے تصورات

یونٹی روبوٹکس روبوٹکس تقلید کے لیے کئی کلیدی اجزاء فراہم کرتا ہے:

- **ROS-TCP-کنیکٹر**: یونٹی اور ROS 2 کے درمیان رابطہ ممکن بناتا ہے
- **یونٹی روبوٹکس پیکیج (URP)**: روبوٹکس کے لیے مخصوص اجزاء اور ٹولز فراہم کرتا ہے
- **مصنوعی ڈیٹا تخلیق**: AI ماڈلز کے لیے لیبل شدہ تربیتی ڈیٹا تیار کرتا ہے
- **ایجادی مواد تخلیق**: خود بخود متنوع تربیتی ماحول تیار کرتا ہے

## تقلید سے حقیقت کی منتقلی کی چیلنجوں

سیم ٹو ریئل کا فرق تقلید اور حقیقت کے درمیان وہ فرق ہے جو تقلید میں تربیت یافتہ الگورتھم کو جسمانی روبوٹس پر ڈپلائے ہونے پر ناکام ہونے کا سبب بن سکتا ہے۔ اہم چیلنج درج ذیل ہیں:

- **بصری وفاداری**: لائٹنگ، ٹیکسچر، اور رینڈرنگ میں فرق
- **فزکس ماڈلنگ**: سادہ فزکس ماڈلز بمقابلہ حقیقی دنیا کی پیچیدگیاں
- **سینسر شور**: تقلید حقیقی سینسر کی خامیوں کو درست طریقے سے نقل نہیں کر سکتا
- **ایکچویٹر متحرکات**: موٹر ریسپانس اور کنٹرول کی درستگی میں فرق

ان چیلنجوں کا سامنا کرنے کے لیے، ڈومین رینڈمائزیشن، سیم ٹو ریئل ٹرانسفر لرننگ، اور سسٹم آئیڈنٹیفکیشن جیسی تکنیکوں کو اپنایا جاتا ہے۔

## تقلید کے بہترین طریقے

1. **آسان شروع کریں**: بنیادی ماڈلز کے ساتھ شروع کریں اور تدریج سے پیچیدگی شامل کریں
2. **فزکس کی توثیق کریں**: یقینی بنائیں کہ تقلیدی پیرامیٹرز جسمانی روبوٹ کی خصوصیات سے مماثل ہوں
3. **سینسر ماڈلز کی جانچ کریں**: یقینی بنائیں کہ سینسر تقلید حقیقی ہارڈ ویئر کے سلوک سے مماثل ہو
4. **اکثر دہرائیں**: تیز پروٹو ٹائپنگ اور جانچ کے لیے تقلید کا استعمال کریں
5. **فرق کو دستاویز کریں**: سیم ٹو ریئل کے معلوم اختلافات کو نوٹ کریں

## خود کوشش کریں

1. **گزیبو گارڈن انسٹال کریں**:
   ```bash
   # اوبنٹو 22.04 پر
   sudo apt update
   sudo apt install gazebo
   ```

2. **ایک سادہ روبوٹ ماڈل تخلیق کریں**:
   - ایک سادہ پہیوں والے روبوٹ کے لیے URDF فائل بنائیں
   - وژول، کولیژن، اور ادراک کی خصوصیات شامل کریں
   - حرکت کے لیے ڈیفرینشل ڈرائیو پلگ ان شامل کریں

3. **ایک تقلید کا آغاز کریں**:
   - گزیبو میں اپنے روبوٹ کو اسپون کرنے کے لیے ایک لانچ فائل بنائیں
   - روبوٹ کی حالت اور سینسر ڈیٹا کو دیکھنے کے لیے RViz استعمال کریں
   - ٹیلی اوب ٹولز کا استعمال کرتے ہوئے بنیادی حرکت کے حکم کی جانچ کریں

4. **رکاوٹ سے بچاؤ نافذ کریں**:
   - لیزر اسکین ڈیٹا کو سبسکرائب کرنے والے ایک ROS 2 نوڈ کو لکھیں
   - رکاوٹ سے بچاؤ یا دیوار کے ساتھ چلنے والا ایک سادہ الگورتھم نافذ کریں
   - حقیقی ہارڈ ویئر پر غور کرنے سے پہلے الگورتھم کو تقلید میں جانچیں

5. **فزکس پیرامیٹرز کے ساتھ تجربہ کریں**:
   - رگڑ کے ضرائب کو ایڈجسٹ کریں اور دیکھیں کہ وہ روبوٹ کی حرکت کو کیسے متاثر کرتے ہیں
   - مختلف ماحول کی نقل کرنے کے لیے گریویٹی کی ترتیبات کو تبدیل کریں
   - کارکردگی کو بہتر بنانے کے لیے مختلف کنٹرول پیرامیٹرز کی جانچ کریں

6. **یونٹی روبوٹکس کو تلاش کریں** (اختیاری):
   - یونٹی ہب اور یونٹی 2022.3 LTS انسٹال کریں
   - یونٹی روبوٹکس پیکیج درآمد کریں
   - TCP کنیکٹر کا استعمال کرتے ہوئے ROS 2 سے منسلک ہوں
   - ایک روبوٹ اور نیویگیشن ماحول کے ساتھ ایک سادہ منظر تخلیق کریں

ان مشقوں کے ذریعے، آپ ڈیجیٹل ٹوئن تصورات اور تقلیدی ماحول کے ساتھ ہاتھ سے کام کا تجربہ حاصل کریں گے جو مضبوط روبوٹکس سسٹمز تیار کرنے کے لیے ضروری ہیں۔ تقلید میں تیار کردہ مہارتیں براہ راست حقیقی دنیا کے روبوٹکس اطلاقوں میں منتقل ہوں گی۔